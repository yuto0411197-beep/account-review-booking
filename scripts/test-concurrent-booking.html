<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>åŒæ™‚äºˆç´„ãƒ†ã‚¹ãƒˆ</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      max-width: 1200px;
      margin: 40px auto;
      padding: 20px;
      background: #f5f5f5;
    }
    .container {
      background: white;
      padding: 30px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    h1 {
      color: #333;
      margin-bottom: 10px;
    }
    .description {
      color: #666;
      margin-bottom: 30px;
      line-height: 1.6;
    }
    .section {
      margin-bottom: 30px;
    }
    label {
      display: block;
      font-weight: 600;
      margin-bottom: 8px;
      color: #333;
    }
    input, select {
      width: 100%;
      padding: 10px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 14px;
      box-sizing: border-box;
    }
    button {
      background: #0070f3;
      color: white;
      border: none;
      padding: 12px 24px;
      border-radius: 4px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      margin-right: 10px;
    }
    button:hover {
      background: #0051cc;
    }
    button:disabled {
      background: #ccc;
      cursor: not-allowed;
    }
    button.secondary {
      background: #666;
    }
    button.secondary:hover {
      background: #444;
    }
    .status {
      margin-top: 20px;
      padding: 15px;
      border-radius: 4px;
      font-family: monospace;
      font-size: 13px;
    }
    .status.info {
      background: #e3f2fd;
      border-left: 4px solid #2196f3;
    }
    .status.success {
      background: #e8f5e9;
      border-left: 4px solid #4caf50;
    }
    .status.error {
      background: #ffebee;
      border-left: 4px solid #f44336;
    }
    .log {
      margin-top: 30px;
      background: #1e1e1e;
      color: #d4d4d4;
      padding: 20px;
      border-radius: 4px;
      max-height: 400px;
      overflow-y: auto;
      font-family: 'Monaco', 'Courier New', monospace;
      font-size: 12px;
      line-height: 1.6;
    }
    .log-entry {
      margin-bottom: 8px;
      border-bottom: 1px solid #333;
      padding-bottom: 8px;
    }
    .log-entry:last-child {
      border-bottom: none;
    }
    .log-success {
      color: #4ec9b0;
    }
    .log-error {
      color: #f48771;
    }
    .log-info {
      color: #569cd6;
    }
    .log-warn {
      color: #dcdcaa;
    }
    .grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>ğŸ”¥ åŒæ™‚äºˆç´„ãƒ†ã‚¹ãƒˆãƒ„ãƒ¼ãƒ«</h1>
    <p class="description">
      ã“ã®ãƒ„ãƒ¼ãƒ«ã¯ã€è¤‡æ•°ã®äºˆç´„ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’åŒæ™‚ã«é€ä¿¡ã—ã¦ã€å®šå“¡è¶…éãŒé˜²æ­¢ã•ã‚Œã‚‹ã‹ã‚’ãƒ†ã‚¹ãƒˆã—ã¾ã™ã€‚<br>
      Row-level lockingã¨RPCé–¢æ•°ãŒæ­£ã—ãå‹•ä½œã—ã¦ã„ã‚Œã°ã€å®šå“¡5åã®æ ã«å¯¾ã—ã¦10ä»¶ã®åŒæ™‚ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’é€ã£ã¦ã‚‚ã€5ä»¶ã ã‘ãŒæˆåŠŸã™ã‚‹ã¯ãšã§ã™ã€‚
    </p>

    <div class="section">
      <label for="apiUrl">API URL (ä¾‹: http://localhost:3000 ã¾ãŸã¯ https://your-app.vercel.app)</label>
      <input type="text" id="apiUrl" value="http://localhost:3000" placeholder="http://localhost:3000">
    </div>

    <div class="section">
      <label for="slotId">ãƒ†ã‚¹ãƒˆå¯¾è±¡ã®æ—¥ç¨‹æ ID</label>
      <input type="text" id="slotId" placeholder="Slot ID (UUIDã‚’å…¥åŠ›)">
      <button onclick="fetchSlots()" style="margin-top: 10px;" class="secondary">æ—¥ç¨‹æ ä¸€è¦§ã‚’å–å¾—</button>
      <select id="slotSelect" style="margin-top: 10px; display: none;" onchange="selectSlot()">
        <option value="">æ—¥ç¨‹æ ã‚’é¸æŠ...</option>
      </select>
    </div>

    <div class="grid">
      <div class="section">
        <label for="concurrency">åŒæ™‚ãƒªã‚¯ã‚¨ã‚¹ãƒˆæ•°</label>
        <input type="number" id="concurrency" value="10" min="1" max="50">
      </div>
      <div class="section">
        <label for="delay">ãƒªã‚¯ã‚¨ã‚¹ãƒˆé–“éš” (ms)</label>
        <input type="number" id="delay" value="0" min="0" max="1000">
      </div>
    </div>

    <div class="section">
      <button onclick="runTest()" id="runBtn">ğŸš€ ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ</button>
      <button onclick="clearLog()" class="secondary">ãƒ­ã‚°ã‚¯ãƒªã‚¢</button>
    </div>

    <div id="status"></div>
    <div id="log" class="log"></div>
  </div>

  <script>
    let testRunning = false;
    let logEntries = [];

    function log(message, type = 'info') {
      const timestamp = new Date().toLocaleTimeString('ja-JP');
      const entry = { timestamp, message, type };
      logEntries.push(entry);
      updateLog();
    }

    function updateLog() {
      const logDiv = document.getElementById('log');
      logDiv.innerHTML = logEntries.map(entry => `
        <div class="log-entry">
          <span class="log-${entry.type}">[${entry.timestamp}]</span> ${entry.message}
        </div>
      `).join('');
      logDiv.scrollTop = logDiv.scrollHeight;
    }

    function clearLog() {
      logEntries = [];
      updateLog();
      document.getElementById('status').innerHTML = '';
    }

    function showStatus(message, type = 'info') {
      const statusDiv = document.getElementById('status');
      statusDiv.className = `status ${type}`;
      statusDiv.textContent = message;
    }

    async function fetchSlots() {
      const apiUrl = document.getElementById('apiUrl').value.trim();
      if (!apiUrl) {
        alert('API URLã‚’å…¥åŠ›ã—ã¦ãã ã•ã„');
        return;
      }

      try {
        log(`æ—¥ç¨‹æ ä¸€è¦§ã‚’å–å¾—ä¸­... (${apiUrl}/api/slots)`, 'info');
        const response = await fetch(`${apiUrl}/api/slots`);

        if (!response.ok) {
          throw new Error(`HTTPã‚¨ãƒ©ãƒ¼: ${response.status}`);
        }

        const slots = await response.json();
        log(`æ—¥ç¨‹æ ã‚’ ${slots.length} ä»¶å–å¾—ã—ã¾ã—ãŸ`, 'success');

        const select = document.getElementById('slotSelect');
        select.innerHTML = '<option value="">æ—¥ç¨‹æ ã‚’é¸æŠ...</option>';

        slots.forEach(slot => {
          const option = document.createElement('option');
          option.value = slot.id;
          const date = new Date(slot.starts_at).toLocaleString('ja-JP');
          const capacity = slot.capacity;
          const booked = slot.booked_count;
          const remaining = capacity - booked;
          option.textContent = `${date} | æ®‹å¸­: ${remaining}/${capacity} | ${slot.status}`;
          option.dataset.slotInfo = JSON.stringify(slot);
          select.appendChild(option);
        });

        select.style.display = 'block';
      } catch (error) {
        log(`ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
        showStatus('æ—¥ç¨‹æ ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ', 'error');
      }
    }

    function selectSlot() {
      const select = document.getElementById('slotSelect');
      const selectedOption = select.options[select.selectedIndex];

      if (selectedOption.value) {
        document.getElementById('slotId').value = selectedOption.value;
        const slotInfo = JSON.parse(selectedOption.dataset.slotInfo);
        log(`æ—¥ç¨‹æ ã‚’é¸æŠ: æ®‹å¸­ ${slotInfo.capacity - slotInfo.booked_count}/${slotInfo.capacity}`, 'info');
      }
    }

    async function runTest() {
      if (testRunning) {
        alert('ãƒ†ã‚¹ãƒˆå®Ÿè¡Œä¸­ã§ã™');
        return;
      }

      const apiUrl = document.getElementById('apiUrl').value.trim();
      const slotId = document.getElementById('slotId').value.trim();
      const concurrency = parseInt(document.getElementById('concurrency').value);
      const delay = parseInt(document.getElementById('delay').value);

      if (!apiUrl || !slotId) {
        alert('API URLã¨æ—¥ç¨‹æ IDã‚’å…¥åŠ›ã—ã¦ãã ã•ã„');
        return;
      }

      testRunning = true;
      document.getElementById('runBtn').disabled = true;

      log('========================================', 'info');
      log('ğŸ”¥ åŒæ™‚äºˆç´„ãƒ†ã‚¹ãƒˆé–‹å§‹', 'warn');
      log(`API URL: ${apiUrl}`, 'info');
      log(`Slot ID: ${slotId}`, 'info');
      log(`åŒæ™‚ãƒªã‚¯ã‚¨ã‚¹ãƒˆæ•°: ${concurrency}`, 'info');
      log(`ãƒªã‚¯ã‚¨ã‚¹ãƒˆé–“éš”: ${delay}ms`, 'info');
      log('========================================', 'info');

      showStatus('ãƒ†ã‚¹ãƒˆå®Ÿè¡Œä¸­...', 'info');

      // ãƒ†ã‚¹ãƒˆé–‹å§‹å‰ã®slotçŠ¶æ…‹ã‚’å–å¾—
      try {
        const slotsResponse = await fetch(`${apiUrl}/api/slots`);
        const slots = await slotsResponse.json();
        const targetSlot = slots.find(s => s.id === slotId);

        if (targetSlot) {
          log(`[äº‹å‰çŠ¶æ…‹] capacity: ${targetSlot.capacity}, booked_count: ${targetSlot.booked_count}, status: ${targetSlot.status}`, 'info');
        }
      } catch (error) {
        log(`äº‹å‰çŠ¶æ…‹ã®å–å¾—ã«å¤±æ•—: ${error.message}`, 'warn');
      }

      const requests = [];
      const startTime = Date.now();

      for (let i = 1; i <= concurrency; i++) {
        const bookingData = {
          slot_id: slotId,
          name: `ãƒ†ã‚¹ãƒˆãƒ¦ãƒ¼ã‚¶ãƒ¼${i}`,
          email: `concurrent-test-${i}-${Date.now()}@example.com`,
          coach_name: `è¬›å¸«${i}`,
          genre: `ãƒ†ã‚¹ãƒˆ${i % 3 === 0 ? 'ãƒ“ã‚¸ãƒã‚¹' : i % 3 === 1 ? 'ã‚¨ãƒ³ã‚¿ãƒ¡' : 'æ•™è‚²'}`
        };

        const request = (async () => {
          if (delay > 0 && i > 1) {
            await new Promise(resolve => setTimeout(resolve, delay * (i - 1)));
          }

          const requestStart = Date.now();

          try {
            const response = await fetch(`${apiUrl}/api/bookings`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(bookingData)
            });

            const result = await response.json();
            const duration = Date.now() - requestStart;

            return {
              index: i,
              success: response.ok,
              status: response.status,
              data: result,
              duration
            };
          } catch (error) {
            return {
              index: i,
              success: false,
              error: error.message,
              duration: Date.now() - requestStart
            };
          }
        })();

        requests.push(request);
      }

      // ã™ã¹ã¦ã®ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’ä¸¦è¡Œå®Ÿè¡Œ
      const results = await Promise.all(requests);
      const totalDuration = Date.now() - startTime;

      // çµæœã‚’é›†è¨ˆ
      const successCount = results.filter(r => r.success).length;
      const failureCount = results.filter(r => !r.success).length;

      log('========================================', 'info');
      log('ğŸ“Š ãƒ†ã‚¹ãƒˆçµæœã‚µãƒãƒªãƒ¼', 'warn');
      log(`ç·å®Ÿè¡Œæ™‚é–“: ${totalDuration}ms`, 'info');
      log(`æˆåŠŸ: ${successCount}ä»¶`, 'success');
      log(`å¤±æ•—: ${failureCount}ä»¶`, 'error');
      log('========================================', 'info');

      // å€‹åˆ¥çµæœã‚’ãƒ­ã‚°å‡ºåŠ›
      results.forEach(result => {
        if (result.success) {
          log(`[æˆåŠŸ #${result.index}] ${result.duration}ms - booking_id: ${result.data.id?.substring(0, 8)}...`, 'success');
        } else {
          const errorMsg = result.error || result.data?.error || 'Unknown error';
          log(`[å¤±æ•— #${result.index}] ${result.duration}ms - ${errorMsg}`, 'error');
        }
      });

      // ãƒ†ã‚¹ãƒˆå¾Œã®slotçŠ¶æ…‹ã‚’å–å¾—
      try {
        await new Promise(resolve => setTimeout(resolve, 500)); // å°‘ã—å¾…ã¤
        const slotsResponse = await fetch(`${apiUrl}/api/slots`);
        const slots = await slotsResponse.json();
        const targetSlot = slots.find(s => s.id === slotId);

        if (targetSlot) {
          log('========================================', 'info');
          log(`[äº‹å¾ŒçŠ¶æ…‹] capacity: ${targetSlot.capacity}, booked_count: ${targetSlot.booked_count}, status: ${targetSlot.status}`, 'info');

          // æ¤œè¨¼
          if (targetSlot.booked_count > targetSlot.capacity) {
            log('âŒ è­¦å‘Š: booked_count ãŒ capacity ã‚’è¶…ãˆã¦ã„ã¾ã™ï¼', 'error');
            showStatus('âŒ ãƒ†ã‚¹ãƒˆå¤±æ•—: å®šå“¡è¶…éãŒç™ºç”Ÿã—ã¾ã—ãŸ', 'error');
          } else if (targetSlot.booked_count === targetSlot.capacity && targetSlot.status === 'closed') {
            log('âœ… æ¤œè¨¼æˆåŠŸ: å®šå“¡ã¡ã‚‡ã†ã©ã§æº€å¸­ã«ãªã‚Šã¾ã—ãŸ', 'success');
            showStatus('âœ… ãƒ†ã‚¹ãƒˆæˆåŠŸ: å®šå“¡è¶…éã¯ç™ºç”Ÿã—ã¾ã›ã‚“ã§ã—ãŸ', 'success');
          } else {
            log('âœ… æ¤œè¨¼æˆåŠŸ: booked_count ã¯ capacity ä»¥ä¸‹ã§ã™', 'success');
            showStatus('âœ… ãƒ†ã‚¹ãƒˆæˆåŠŸ: å®šå“¡è¶…éã¯ç™ºç”Ÿã—ã¾ã›ã‚“ã§ã—ãŸ', 'success');
          }
          log('========================================', 'info');
        }
      } catch (error) {
        log(`äº‹å¾ŒçŠ¶æ…‹ã®å–å¾—ã«å¤±æ•—: ${error.message}`, 'warn');
      }

      testRunning = false;
      document.getElementById('runBtn').disabled = false;
    }

    // åˆæœŸãƒ­ã‚°
    log('åŒæ™‚äºˆç´„ãƒ†ã‚¹ãƒˆãƒ„ãƒ¼ãƒ«ã‚’èµ·å‹•ã—ã¾ã—ãŸ', 'info');
    log('1. API URLã‚’ç¢ºèªã—ã¦ãã ã•ã„ï¼ˆãƒ­ãƒ¼ã‚«ãƒ«: http://localhost:3000ï¼‰', 'info');
    log('2. ã€Œæ—¥ç¨‹æ ä¸€è¦§ã‚’å–å¾—ã€ãƒœã‚¿ãƒ³ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦ãã ã•ã„', 'info');
    log('3. ãƒ†ã‚¹ãƒˆã™ã‚‹æ—¥ç¨‹æ ã‚’é¸æŠã—ã¦ãã ã•ã„', 'info');
    log('4. ã€Œãƒ†ã‚¹ãƒˆå®Ÿè¡Œã€ãƒœã‚¿ãƒ³ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦ãã ã•ã„', 'info');
  </script>
</body>
</html>
